# Postgres PRO: Bash Executor


## Введение
Эта документация описывает REST API, предоставляемый приложением для выполнения команд. Каждая команда представляет собой bash-скрипт. Приложение позволяет параллельно запускать произвольное количество команд.


## Запуск

### Требования
- Операционная система: MacOS или Linux.
- Docker и Docker Compose.

### Шаги
1. Клонировать репозиторий:
```
git clone https://github.com/LSTC000/pg-sh-executor.git
```

2. Создать файл `.env` используя `.env.local` с указанными параметрами для Postgres и проекта _(можно использовать значения по умолчанию)_.

3. Запустить сервер, используя одну из следующих команд:
- С использованием Makefile:
```
sudo make docker-prod
```
- С использованием Docker Compose:
```
sudo docker compose -f ./deploy/docker-compose.prod.yaml up
```


## Документация API

### Базовый URL
Базовый URL для всех конечных точек - `http://0.0.0.0:8000/api/v1`.

### Swagger URL
Swagger URL для всех конечных точек - `http://0.0.0.0:8000/docs/index.html#/`.

### Обработка ошибок
API возвращает стандартные коды состояния HTTP. В случае ошибки дополнительная информация может быть предоставлена в теле ответа, следуя структуре, определенной в схеме `HTTPError`.

Структура `HTTPError`:

- `HTTPCode`: Код состояния HTTP, который будет возвращен в ответе.
- `ServiceCode`: Код ошибки на уровне приложения.
- `Detail`: Дополнительная информация об ошибке.


### Конечные точки

#### 1. Создание Bash скрипта
- **URL:** `/bash`
- **Метод:** POST
- **Описание:** Загрузка файла Bash скрипта для записи новой сущности Bash скрипта в Postgres.
- **Тело запроса:**
- `file` (multipart/form-data): Файл скрипта Bash
- **Ответ:**
- `200 OK`: Возвращает созданный Bash скрипт в формате JSON.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.

#### 2. Выполнение списка Bash скриптов
- **URL:** `/bash/execute/list`
- **Метод:** POST
- **Описание:** Выполнение списка Bash скриптов.
- **Тело запроса:**
- `isSync` (параметр запроса): Если true, то скрипты выполняются в многопоточном режиме; в противном случае выполняются в одном потоке.
- `execute` (параметр тела): Список моделей Bash скриптов для выполнения.
- **Ответ:**
- `200 OK`: Указывает на успешное выполнение.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.

#### 3. Получение списка Bash скриптов
- **URL:** `/bash/list`
- **Метод:** GET
- **Описание:** Получение пагинированного списка всех Bash скриптов.
- **Параметры запроса:**
- `limit` (опционально, по умолчанию: 20): Параметр ограничения для пагинации.
- `offset` (опционально, по умолчанию: 0): Параметр смещения для пагинации.
- **Ответ:**
- `200 OK`: Возвращает пагинированный список Bash скриптов.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.

#### 4. Получение списка логов Bash скрипта по его ID
- **URL:** `/bash/log/{bashId}/list`
- **Метод:** GET
- **Описание:** Получение пагинированного списка логов Bash скрипта по его ID.
- **Параметры пути:**
- `bashId`: ID Bash скрипта.
- **Параметры запроса:**
- `limit` (опционально, по умолчанию: 20): Параметр ограничения для пагинации.
- `offset` (опционально, по умолчанию: 0): Параметр смещения для пагинации.
- **Ответ:**
- `200 OK`: Возвращает пагинированный список логов  Bash скрипта.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.

#### 5. Получение Bash скрипта по его ID
- **URL:** `/bash/{id}`
- **Метод:** GET
- **Описание:** Получение Bash скрипта по его ID.
- **Параметры пути:**
- `id`: ID Bash скрипта.
- **Ответ:**
- `200 OK`: Возвращает модель Bash скрипта в формате JSON.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.

#### 6. Удаление Bash скрипта по его ID
- **URL:** `/bash/{id}`
- **Метод:** DELETE
- **Описание:** Удаление Bash скрипта по его ID.
- **Параметры пути:**
- `id`: ID Bash скрипта.
- **Ответ:**
- `200 OK`: Возвращает модель удалённого Bash скрипта в формате JSON.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.

#### 7. Получение файла Bash скрипта по его ID
- **URL:** `/bash/{id}/file`
- **Метод:** GET
- **Описание:** Получение файла Bash скрипта по его ID.
- **Параметры пути:**
- `id`: ID Bash скрипта.
- **Ответ:**
- `200 OK`: Возвращает файл Bash скрипта.
- `!200 Error`: Возвращает ошибку в виде схемы `HTTPError`.


## Тесты
В проекте реализованы unit-тесты для слоёв обработчиков конечных точек _(handlers)_ и бизнес-логики _(usecases)_.

### Требования
- Язык программирования GO версии `>=1.18`.

### Шаги
1. Установить зависимости:
```
go mod download
```

2. Запустить тесты:
- С использованием Makefile:
```
make test-run
```
- С использованием GO:
```
go test -v -count=1 ./...
```


## Принятые в ходе разработки решения
1. **Использование фреймворка Gin на основе Golang**: Для разработки API был выбран фреймворк Gin. Использование Gin предоставляет ряд преимуществ:

- **Высокая производительность**: Gin является одним из самых быстрых фреймворков для разработки веб-приложений на Golang. Его минималистичный дизайн и оптимизированный код обеспечивают высокую скорость обработки HTTP запросов.

- **Простота использования**: Gin предоставляет простой и интуитивно понятный интерфейс для создания API. Его структурированный подход к маршрутизации и обработке запросов упрощает разработку и поддержку кода.

- **Богатая функциональность**: Gin предоставляет широкий набор функций и возможностей для разработки веб-приложений, включая маршрутизацию, обработку запросов, обработку ошибок, мидлвары и многое другое. Это позволяет быстро и эффективно реализовывать требуемый функционал приложения.

- **Активное сообщество**: Gin имеет активное сообщество разработчиков и поддерживается регулярными обновлениями и исправлениями ошибок. Это обеспечивает надежность и стабильность фреймворка, а также обеспечивает доступ к большому объему документации и примеров использования.

2. **API документация с использованием Swagger**: Для удобства использования и интеграции с другими сервисами было решено предоставить документацию к API с использованием Swagger. Это облегчает понимание функционала приложения и его использование сторонними разработчиками.

3. **Отдельный запрос на получение логов выполнения Bash скрипта**: Для улучшения гибкости и эффективности взаимодействия с API было принято решение выдавать логи выполнения Bash скрипта не в составе запроса на получение самого скрипта, а в отдельном запросе. Такой подход позволяет клиентскому приложению выбирать, когда и как получать логи, что может быть особенно полезно в случае, когда получение логов не всегда необходимо. Это также позволяет снизить нагрузку на сервер и упростить обработку запросов клиентским приложением, так как не нужно будет тянуть за собой логи при каждом запросе на получение скрипта.

4. **Поддержка limit offset пагинации в списках команд и логов**: Для управления списками команд и логов была выбрана пагинация с использованием параметров limit и offset, а не курсорная пагинация. Данный выбор обоснован несколькими причинами:

- **Простота реализации и использования**: limit offset пагинация проще в реализации и использовании по сравнению с курсорной пагинацией. Она понятна и привычна для большинства разработчиков, что упрощает понимание кода и управление данными в списках команд и логов.

- **Невысокие требования к производительности**: В данном контексте не ожидается высоких требований к производительности при обработке запросов на пагинацию. Однако, в случае курсорной пагинации могли бы возникнуть дополнительные затраты на ресурсы при вычислении курсоров и обработке запросов, что может быть излишним в условиях ограниченного объема данных.

- **Гибкость и контроль**: limit offset пагинация предоставляет гибкость и контроль над списками команд и логов. Разработчики могут легко управлять количеством возвращаемых записей и смещением, что обеспечивает удобство и адаптивность при работе с данными.

5. **Реализация возможности удаления команд**: Для обеспечения управления данными была добавлена возможность удаления команд. Это позволяет пользователям эффективно управлять своими ресурсами и поддерживать порядок в базе данных.

6. **Реализация возможности получения файла Bash скрипта по его ID**: Для удобства пользователя была добавлена возможность получения файла Bash скрипта по его ID. Это упрощает доступ к исходному коду команды и улучшает процесс отладки и анализа.

7. **Отсутствие требований к аутентификации в текущей версии**: На текущем этапе разработки доступ к конечным точкам API не требует аутентификации. Однако, в дальнейшем этот функционал может быть добавлен в зависимости от требований безопасности.

Эти решения были приняты на основе требований к функционалу приложения, а также с учетом общих принципов проектирования и разработки программного обеспечения.
